{"messages":[{"role":"system","content":"show an animation of what a circle is?"},{"role":"model","content":"from manim import *\n\nclass DrawCircle(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        # Set color and line width\n        circle.set_fill(PINK, opacity=0.5)\n        circle.set_stroke(color=WHITE, width=4)\n\n        # Show creation of the circle\n        self.play(Create(circle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a square?"},{"role":"model","content":"from manim import *\n\nclass DrawSquare(Scene):\n    def construct(self):\n        # Create a square\n        square = Square()\n        # Set color and line width\n        square.set_fill(BLUE, opacity=0.5)\n        square.set_stroke(color=WHITE, width=4)\n\n        # Show creation of the square\n        self.play(Create(square))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of equilateral triangle?"},{"role":"model","content":"from manim import *\n\nclass DrawTriangle(Scene):\n    def construct(self):\n        # Create an equilateral triangle\n        triangle = Polygon(np.array([0, 1, 0]), np.array([-1, -1, 0]), np.array([1, -1, 0]))\n        # Set color and line width\n        triangle.set_fill(YELLOW, opacity=0.5)\n        triangle.set_stroke(color=WHITE, width=4)\n\n        # Show creation of the triangle\n        self.play(Create(triangle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of combining shapes like a circle, square, and triangle?"},{"role":"model","content":"from manim import *\n\nclass CombineShapes(Scene):\n    def construct(self):\n        # Create a circle\n        circle = Circle()\n        circle.set_fill(RED, opacity=0.5)\n        circle.set_stroke(color=WHITE, width=4)\n\n        # Create a square\n        square = Square()\n        square.set_fill(BLUE, opacity=0.5)\n        square.set_stroke(color=WHITE, width=4)\n\n        # Create an equilateral triangle\n        triangle = Polygon(np.array([0, 1, 0]), np.array([-1, -1, 0]), np.array([1, -1, 0]))\n        triangle.set_fill(GREEN, opacity=0.5)\n        triangle.set_stroke(color=WHITE, width=4)\n\n        # Arrange the shapes in a row\n        shapes = VGroup(circle, square, triangle).arrange(RIGHT, buff=1)\n\n        # Show creation of the shapes\n        self.play(Create(shapes))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of transforming a square into a circle?"},{"role":"model","content":"from manim import *\n\nclass TransformShape(Scene):\n    def construct(self):\n        # Create a square and a circle\n        square = Square()\n        circle = Circle()\n\n        # Position the square\n        square.shift(LEFT)\n\n        # Position the circle\n        circle.shift(RIGHT)\n\n        # Show square and transform it into circle\n        self.play(Create(square), Transform(square, circle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of rotating a pentagon?"},{"role":"model","content":"from manim import *\n\nclass RotateShape(Scene):\n    def construct(self):\n        # Create a pentagon\n        pentagon = RegularPolygon(5)\n\n        # Set color\n        pentagon.set_fill(PURPLE, opacity=0.5)\n\n        # Rotate the pentagon\n        self.play(Rotate(pentagon, angle=2*PI))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of plotting the linear function y=2x+1?"},{"role":"model","content":"from manim import *\n\nclass PlotLinearFunction(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 5, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Create a line based on the equation y = 2x + 1\n        line = axes.plot(lambda x: 2*x + 1, color=GREEN)\n\n        # Label for the line\n        line_label = axes.get_graph_label(line, label='y=2x+1')\n\n        # Draw the line with an animation\n        self.play(Create(axes), Create(line), Write(line_label))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of plotting the quadratic function y=x^2?"},{"role":"model","content":"from manim import *\n\nclass PlotQuadraticFunction(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-1, 10, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Create a quadratic function graph y = x^2\n        graph = axes.plot(lambda x: x**2, color=RED)\n\n        # Label for the graph\n        graph_label = axes.get_graph_label(graph, label='y=x^2')\n\n        # Create the axes and graph with an animated drawing\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of graphing multiple functions, specifically y = x and y = x^2?"},{"role":"model","content":"from manim import *\n\nclass GraphMultipleFunctions(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 9, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Function y = x\n        linear_function = axes.plot(lambda x: x, color=GREEN)\n        linear_label = MathTex('y = x').next_to(linear_function, UP+LEFT)\n\n        # Function y = x^2\n        quadratic_function = axes.plot(lambda x: x**2, color=RED)\n        quadratic_label = MathTex('y = x^2').next_to(quadratic_function, UP+RIGHT)\n\n        # Add all elements to the scene\n        graph = VGroup(axes, linear_function, linear_label, quadratic_function, quadratic_label)\n        self.play(Create(graph))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a parametric spiral?"},{"role":"model","content":"from manim import *\n\nclass ParametricSpiral(Scene):\n    def construct(self):\n        # Define a parametric curve for a spiral\n        def spiral(t):\n            return np.array([\n                t * np.cos(t),\n                t * np.sin(t),\n                0\n            ])\n\n        # Create a curve based on the spiral function\n        spiral_curve = ParametricFunction(\n            spiral, t_range = np.array([0, 10, 0.1]),\n            color = BLUE\n        )\n\n        # Add the curve to the scene and animate\n        self.play(Create(spiral_curve))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a Sierpinski triangle?"},{"role":"model","content":"from manim import *\n\nclass SierpinskiTriangle(Scene):\n    def construct(self):\n        # Recursive function to create Sierpinski triangle\n        def sierpinski(order, scale):\n            if order == 0:\n                return Triangle().scale(scale)\n            else:\n                triangle = sierpinski(order - 1, scale / 2)\n                return VGroup(\n                    triangle.copy().shift(LEFT*scale),\n                    triangle.copy().shift(RIGHT*scale),\n                    triangle.copy().shift(UP*scale)\n                )\n\n        # Create Sierpinski triangle of order 3\n        sierpinski_triangle = sierpinski(3, 2)\n\n        # Add the fractal to the scene and animate\n        self.play(Create(sierpinski_triangle))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a hexagon tessellation?"},{"role":"model","content":"from manim import *\n\nclass HexagonTessellation(Scene):\n    def construct(self):\n        # Create a hexagon\n        def hexagon():\n            return RegularPolygon(6, radius=1, stroke_color=BLUE, fill_color=ORANGE, fill_opacity=0.6)\n\n        # Arrange hexagons into a tessellation pattern\n        tessellation = VGroup(*[\n            hexagon().shift(i * np.sqrt(3) * RIGHT + j * np.sqrt(3) * UP * 0.5)\n            for i in range(-5, 5) for j in range(-5, 5)\n            if (i+j)%2 == 0\n        ])\n\n        # Add the tessellation to the scene and animate\n        self.play(Create(tessellation))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of the multiplication of complex numbers 1+2i and 2+1i?"},{"role":"model","content":"from manim import *\n\nclass ComplexNumberMultiplication(Scene):\n    def construct(self):\n        # Setup complex plane\n        plane = ComplexPlane().add_coordinates()\n        # Multiplication of two complex numbers\n        num1 = complex(1, 2)  # represented by 1 + 2i\n        num2 = complex(2, 1)  # represented by 2 + 1i\n        result = num1 * num2  # Result of the multiplication\n\n        # Plot points for complex numbers and the result\n        dot1 = Dot(plane.n2p(num1), color=YELLOW)\n        dot2 = Dot(plane.n2p(num2), color=RED)\n        result_dot = Dot(plane.n2p(result), color=GREEN)\n        dots = VGroup(dot1, dot2, result_dot)\n\n        # Labels for the points\n        dot1_label = MathTex(\"1+2i\").next_to(dot1, UP)\n        dot2_label = MathTex(\"2+1i\").next_to(dot2, UP)\n        result_label = MathTex(\"5i\").next_to(result_dot, UP)\n        labels = VGroup(dot1_label, dot2_label, result_label)\n\n        # Create and animate everything together\n        self.play(Create(plane), FadeIn(dots, labels, shift=UP), run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of the Pythagorean Theorem?"},{"role":"model","content":"from manim import *\n\nclass PythagorasTheorem(Scene):\n    def construct(self):\n        # Define the points of the right-angled triangle\n        pointA = ORIGIN\n        pointB = 4 * RIGHT\n        pointC = 4 * RIGHT + 3 * UP\n\n        # Create the triangle\n        triangle = Polygon(pointA, pointB, pointC, color=WHITE)\n        triangle.set_fill(BLUE, opacity=0.5)\n\n        # Labels for the sides of the triangle\n        a_label = MathTex(\"c\", color=RED).next_to(triangle, LEFT, buff=0.1)\n        b_label = MathTex(\"b\", color=GREEN).next_to(triangle, DOWN, buff=0.1)\n        c_label = MathTex(\"a\", color=BLUE).next_to(triangle, RIGHT, buff=0.1)\n\n        # Heading for context\n        heading = Text(\"Pythagorean Theorem\", font_size=36).to_edge(UP)\n\n        # The theorem formula\n        theorem_formula = MathTex(\"c^2 = a^2 + b^2\", color=PURPLE).scale(1.5).next_to(heading, DOWN)\n\n        # Grouping all elements for a single animation command\n        all_elements = VGroup(triangle, a_label, b_label, c_label, heading, theorem_formula)\n\n        # Animate all elements together using DrawBorderThenFill for a coherent drawing effect\n        self.play(DrawBorderThenFill(all_elements), run_time=3)\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of visualizing the derivative of f(x) = x^2?"},{"role":"model","content":"from manim import *\n\nclass VisualizeDerivative(Scene):\n    def construct(self):\n        # Create axes and plots for the function and its derivative\n        axes = Axes(x_range=[-3, 3, 1], y_range=[-5, 5, 1], axis_config={'color': BLUE})\n        func = axes.plot(lambda x: x**2, color=RED)\n        derivative = axes.plot(lambda x: 2*x, color=GREEN)\n        graphs = VGroup(axes, func, derivative)\n\n        # Labels for the functions\n        func_label = MathTex('f(x) = x^2').next_to(func, UP)\n        derivative_label = MathTex(\"f'(x) = 2x\").next_to(derivative, UP+RIGHT)\n        labels = VGroup(func_label, derivative_label)\n\n        # Create and animate everything together\n        self.play(Create(graphs), FadeIn(labels, shift=UP), run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of the orbital mechanics of a planet around the sun?"},{"role":"model","content":"from manim import *\n\nclass OrbitalMechanics(Scene):\n    def construct(self):\n        # Define the colors and sizes for higher visibility\n        sun_color = YELLOW\n        planet_color = BLUE\n\n        # Sun setup\n        sun = Circle(radius=1, color=sun_color)  # Larger radius for the sun\n        sun.set_fill(sun_color, opacity=1)\n        sun.move_to(ORIGIN)\n\n        # Planet setup with explicit visibility enhancements\n        planet = Dot(radius=0.3, color=planet_color)  # Increased the radius of the planet\n        planet.set_fill(planet_color, opacity=1)\n        planet.move_to(5 * RIGHT)  # Increase the distance to make the orbit larger\n\n        # Orbit path (ellipse to represent the orbital path)\n        orbit_path = Ellipse(width=10, height=4, color=WHITE)  # Larger and wider orbit path\n\n        # Animation for the planet orbiting the sun\n        orbit_animation = Rotating(planet, about_point=ORIGIN, radians=2*PI, run_time=3, rate_func=smooth)\n\n        # Drawing the sun, planet, and orbit path with a clear distinction\n        self.play(\n            DrawBorderThenFill(sun),\n            Create(orbit_path),\n            GrowFromCenter(planet),\n            orbit_animation\n        )\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of the wave interference from two sources?"},{"role":"model","content":"from manim import *\n\nclass WaveInterference(Scene):\n    def construct(self):\n        # Wave sources\n        source_a = Dot(LEFT * 2)\n        source_b = Dot(RIGHT * 2)\n        waves_a = Circle(radius=2, color=BLUE).move_to(source_a.get_center())\n        waves_b = Circle(radius=2, color=RED).move_to(source_b.get_center())\n\n        # Interference pattern setup\n        interference_pattern = VGroup(waves_a, waves_b)\n\n        # Group all elements and animate\n        self.play(DrawBorderThenFill(source_a), DrawBorderThenFill(source_b), Create(interference_pattern), run_time=4)\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a bar chart for given categories?"},{"role":"model","content":"from manim import *\n\nclass BarChartExample(Scene):\n    def construct(self):\n        # Data for the bar chart\n        data = [2, 5, 3, 6]  # Sample data values\n        categories = ['A', 'B', 'C', 'D']  # Categories for the data\n\n        # Create a bar chart\n        bar_chart = BarChart(\n            values=data,\n            bar_names=categories,\n            bar_colors=[BLUE, YELLOW, GREEN, RED],\n            y_range=[0, 10, 1],  # Setting the range for the y-axis\n            y_length=6,  # The vertical length of the bars\n            x_length=6,  # The horizontal spacing of the bars\n        )\n\n        # Title for the bar chart\n        title = Title('Bar Chart Example')\n\n        # Animate the creation of the bar chart\n        self.play(\n            Write(title),\n            Create(bar_chart),\n            run_time=4\n        )\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a pie chart for given percentages?"},{"role":"model","content":"from manim import *\n\nclass PieChartExample(Scene):\n    def construct(self):\n        # Data for the pie chart\n        data = [30, 15, 20, 35]  # Percentages of each sector\n        colors = [TEAL, ORANGE, PURPLE_A, GOLD]  # Colors for each sector\n\n        # Total of all segments\n        total = sum(data)\n        current_angle = 0  # Start angle for the first segment\n        radius = 2  # Radius of the pie chart\n\n        # Create a pie chart from the data\n        pie_chart = VGroup()  # Initialize a group to store pie slices\n        labels = VGroup()  # Group for labels\n\n        for i, value in enumerate(data):\n            # Calculate the angle covered by the segment\n            angle = value / total * 360 * DEGREES\n\n            # Create a sector (pie slice)\n            sector = Sector(\n                start_angle=current_angle,\n                angle=angle,\n                color=colors[i],\n                fill_opacity=0.8,\n                outer_radius=radius\n            )\n\n            # Calculate label position\n            label_position = sector.get_center() + np.array([\n                radius * 0.75 * np.cos(current_angle + angle / 2),\n                radius * 0.75 * np.sin(current_angle + angle / 2),\n                0\n            ])\n\n            # Create label for the sector\n            label = MathTex(f\"{value}%\")\n            label.move_to(label_position)\n\n            # Add sector and label to their respective groups\n            pie_chart.add(sector)\n            labels.add(label)\n\n            # Update the start angle for the next sector\n            current_angle += angle\n\n        # Center the pie chart\n        pie_chart.move_to(ORIGIN)\n        labels.move_to(ORIGIN)\n\n        # Title for the pie chart\n        title = Title(\"Pie Chart Example\")\n\n        # Animate everything\n        self.play(\n            FadeIn(title),\n            Create(pie_chart),\n            FadeIn(labels),\n            run_time=4\n        )\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a historical timeline from 1900 to 2000 highlighting major events?"},{"role":"model","content":"from manim import *\n\nclass HistoricalTimeline(Scene):\n    def construct(self):\n        # Timeline setup\n        timeline = Line(LEFT * 5, RIGHT * 5, color=WHITE)\n        start_label = Text(\"1900\", font_size=24).next_to(timeline.get_start(), DOWN)\n        end_label = Text(\"2000\", font_size=24).next_to(timeline.get_end(), DOWN)\n\n        # Events\n        events = [\n            (\"WWI\", -4),\n            (\"Great Depression\", -2),\n            (\"WWII\", 0),\n            (\"Moon Landing\", 2),\n            (\"Fall of Berlin Wall\", 4),\n        ]\n\n        # Create event markers and labels\n        dots = VGroup()\n        labels = VGroup()\n        for event, pos in events:\n            dot = Dot().move_to(timeline.point_from_proportion((pos + 5) / 10))\n            label = Text(event, font_size=18).next_to(dot, UP)\n            dots.add(dot)\n            labels.add(label)\n\n        # Animate\n        self.play(Create(timeline), Write(start_label), Write(end_label))\n        self.wait(1)\n        for dot, label in zip(dots, labels):\n            self.play(GrowFromCenter(dot), Write(label))\n            self.wait(0.5)\n        \n        # Final wait\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a pentagon?"},{"role":"model","content":"from manim import *\n\nclass DrawPentagon(Scene):\n    def construct(self):\n        # Create a regular pentagon\n        pentagon = RegularPolygon(5)\n        # Set color and line width\n        pentagon.set_fill(ORANGE, opacity=0.5)\n        pentagon.set_stroke(color=WHITE, width=4)\n\n        # Animate the creation of the pentagon\n        self.play(Create(pentagon))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of the graph of the sine function?"},{"role":"model","content":"from manim import *\n\nclass PlotSineWave(Scene):\n    def construct(self):\n        # Create axes\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[-2, 2, 1],\n            axis_config={'color': BLUE}\n        )\n\n        # Create the sine wave graph\n        sine_wave = axes.plot(lambda x: np.sin(x), color=GREEN)\n\n        # Label for the sine wave\n        label = axes.get_graph_label(sine_wave, label='y = \\sin(x)')\n\n        # Draw axes and sine wave\n        self.play(Create(axes), Create(sine_wave), Write(label))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a 3D helix?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass Plot3DHelix(ThreeDScene):\n    def construct(self):\n        # Set up axes\n        axes = ThreeDAxes(\n            x_range=[-4, 4, 1],\n            y_range=[-4, 4, 1],\n            z_range=[-2, 2, 1]\n        )\n\n        # Define the parametric function for a helix\n        helix = ParametricFunction(\n            lambda t: np.array([\n                np.cos(t),\n                np.sin(t),\n                t / 2  # Control the vertical displacement\n            ]),\n            t_range=np.array([0, 10*PI, 0.1]),  # Several twists\n            color=RED\n        )\n\n        # Draw everything\n        self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)\n        self.add(axes)\n        self.play(Create(helix))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a 3D surface plot for the function z=sin(x) * cos(y)?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass Surface3DPlot(ThreeDScene):\n    def construct(self):\n        # Create axes\n        axes = ThreeDAxes(\n            x_range=[-3, 3, 1],\n            y_range=[-3, 3, 1],\n            z_range=[-1, 1, 0.5]\n        )\n\n        # Define the surface function z = sin(x) * cos(y)\n        surface = Surface(\n            lambda u, v: axes.c2p(u, v, np.sin(u) * np.cos(v)),\n            u_range=[-PI, PI],\n            v_range=[-PI, PI],\n            color=BLUE\n        )\n\n        # Set up the scene\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n        self.add(axes)\n        self.play(Create(surface))\n        self.begin_ambient_camera_rotation(rate=0.2)  # Optional: Rotate the camera\n        self.wait(4)"}]}
{"messages":[{"role":"system","content":"show an animation of a 3D rotation of a cube and a sphere?"},{"role":"model","content":"from manim import *\n\nclass CubeSphereRotation(ThreeDScene):\n    def construct(self):\n        # Create a cube and a sphere\n        cube = Cube()\n        sphere = Sphere()\n\n        # Position the sphere to the right of the cube\n        sphere.shift(RIGHT * 3)\n\n        # Set initial colors\n        cube.set_color(BLUE)\n        sphere.set_color(RED)\n\n        # Prepare the scene\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n        self.add(cube, sphere)\n        self.wait(1)\n\n        # Animate rotation around the y-axis\n        self.play(Rotate(cube, angle=PI/2, axis=UP), Rotate(sphere, angle=PI/2, axis=UP), run_time=2)\n        self.wait(1)\n\n        # Further rotation around the x-axis\n        self.play(Rotate(cube, angle=PI/2, axis=RIGHT), Rotate(sphere, angle=PI/2, axis=RIGHT), run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a 3D vector field?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass VectorField3D(ThreeDScene):\n    def construct(self):\n        # Define a vector field\n        field = ArrowVectorField(\n            lambda pos: np.cross(pos, OUT + SMALL_BUFF * UP),\n            x_range=[-2, 2, 1],\n            y_range=[-2, 2, 1],\n            z_range=[-2, 2, 1]\n        )\n\n        # Set up the camera\n        self.set_camera_orientation(phi=45 * DEGREES, theta=135 * DEGREES)\n        self.add(field)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(4)"}]}
{"messages":[{"role":"system","content":"show an animation of a surface of revolution generated from a parabola?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass SurfaceOfRevolution(ThreeDScene):\n    def construct(self):\n        # Define a parabola\n        def curve(t):\n            return np.array([t, t**2, 0])\n\n        # Generate the surface of revolution\n        surface = Surface(\n            lambda u, v: curve(u) @ np.array([\n                [np.cos(v), 0, np.sin(v)],\n                [0, 1, 0],\n                [-np.sin(v), 0, np.cos(v)]\n            ]),\n            u_range=[-2, 2],  # range for the parabola\n            v_range=[0, 2 * PI],  # full circle revolution\n            checkerboard_colors=[BLUE_D, BLUE_E],\n            resolution=(20, 20)\n        )\n\n        # Setup the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.add(surface)\n        self.wait(1)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"}]}
{"messages":[{"role":"system","content":"show an animation of colliding pendulums?"},{"role":"model","content":"from manim import *\n\nclass CollidingPendulums(Scene):\n    def construct(self):\n        # Create two pendulums\n        pendulum1 = Line(UP * 2, DOWN * 2).set_stroke(width=3).move_to(LEFT * 2)\n        pendulum2 = Line(UP * 2, DOWN * 2).set_stroke(width=3).move_to(RIGHT * 2)\n        ball1 = Circle(radius=0.2, color=BLUE).next_to(pendulum1, DOWN)\n        ball2 = Circle(radius=0.2, color=RED).next_to(pendulum2, DOWN)\n        \n        # Grouping them\n        group1 = VGroup(pendulum1, ball1)\n        group2 = VGroup(pendulum2, ball2)\n\n        # Animation\n        self.play(FadeIn(group1), FadeIn(group2))\n        self.play(Rotate(group1, angle=PI/4, about_point=UP*2 + LEFT*2),\n                  Rotate(group2, angle=-PI/4, about_point=UP*2 + RIGHT*2),\n                  run_time=2, rate_func=there_and_back, repeat=3)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of an expanding and collapsing circle grid?"},{"role":"model","content":"from manim import *\n\nclass ExpandingCollapsingCircleGrid(Scene):\n    def construct(self):\n        # Create a grid of circles\n        grid = VGroup(*[Circle(radius=0.2, color=WHITE).shift(x * RIGHT + y * UP)\n                       for x in range(-4, 5, 2)\n                       for y in range(-3, 4, 2)])\n\n        # Animation\n        self.play(LaggedStart(*[GrowFromCenter(circle) for circle in grid], lag_ratio=0.1),\n                  run_time=2)\n        self.wait(1)\n        self.play(LaggedStart(*[ShrinkToCenter(circle) for circle in grid], lag_ratio=0.1),\n                  run_time=2)\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of an evolving Lissajous curve?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass LissajousAnimation(Scene):\n    def construct(self):\n        # Lissajous curve parameters that evolve over time\n        a = 3\n        b = 2\n        delta = PI / 2\n\n        # Create a Lissajous curve\n        lissajous_curve = ParametricFunction(\n            lambda t: np.array([\n                np.sin(a * t + delta),\n                np.sin(b * t),\n                0\n            ]),\n            t_range=[0, 2*PI],\n            color=RED\n        )\n\n        # Animating the evolution of the curve\n        self.play(Create(lissajous_curve), run_time=2)\n        self.wait(1)\n\n        # Change parameters over time\n        self.play(lissajous_curve.animate.set_function(\n            lambda t: np.array([\n                np.sin((a+1) * t + delta),\n                np.sin((b+1) * t),\n                0\n            ])\n        ), run_time=5)\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of bouncing balls in a box with gravity?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass BouncingBalls(Scene):\n    def construct(self):\n        box = Rectangle(height=6, width=6).set_color(WHITE)\n        balls = VGroup(*[Circle(radius=0.2, color=random_bright_color()).move_to(\n            np.array([np.random.uniform(-3, 3), np.random.uniform(-3, 3), 0]))\n            for _ in range(5)])\n        gravity = np.array([0, -0.1, 0])\n        velocities = [np.random.uniform(-1, 1, size=3) for _ in balls]\n\n        self.add(box, balls)\n        for _ in range(200):  # 200 frames of animation\n            self.wait(0.05)\n            for ball, vel in zip(balls, velocities):\n                new_point = ball.get_center() + vel\n                if not (-3 <= new_point[0] <= 3 and -3 <= new_point[1] <= 3):\n                    vel *= -1  # Reverse the velocity if it hits the walls\n                vel += gravity  # Apply gravity to velocity\n                ball.shift(vel)"}]}
{"messages":[{"role":"system","content":"show an animation of the Moon orbiting around the Earth?"},{"role":"model","content":"from manim import *\n\nclass EarthMoonOrbit(ThreeDScene):\n    def construct(self):\n        # Set up the scene with Earth and Moon\n        earth = Sphere(radius=1, color=BLUE, resolution=(32, 32))\n        moon = Sphere(radius=0.2, color=GRAY, resolution=(32, 32)).shift(RIGHT * 3)  # 3 units away from Earth\n\n        # Add Earth and Moon to the scene\n        self.add(earth, moon)\n\n        # Set up the camera\n        self.set_camera_orientation(phi=75 * DEGREES, theta=45 * DEGREES)\n        \n        # Animate the Moon orbiting around the Earth\n        self.play(Rotate(moon, about_point=ORIGIN, angle=2*PI, run_time=10, rate_func=linear))\n\n        # Keep the camera stationary and let the animation loop\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a wormhole?"},{"role":"model","content":"from manim import *\n\nclass WormholeIllustration(ThreeDScene):\n    def construct(self):\n        # Define spheres representing entry and exit points\n        sphere1 = Sphere(radius=1, color=BLUE).shift(LEFT * 3)\n        sphere2 = Sphere(radius=1, color=RED).shift(RIGHT * 3)\n\n        # Define the \"throat\" of the wormhole as a cylinder\n        throat = Cylinder(radius=0.5, height=6, direction=RIGHT * 6).set_color(GREEN)\n\n        # Set up the scene\n        self.set_camera_orientation(phi=45 * DEGREES, theta=45 * DEGREES)\n        self.add(sphere1, sphere2, throat)\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"}]}
{"messages":[{"role":"system","content":"show an animation of a planetary orbit system?"},{"role":"model","content":"from manim import *\n\nclass PlanetaryOrbitSystem(ThreeDScene):\n    def construct(self):\n        # Create the sun and planets\n        sun = Sphere(radius=1, color=YELLOW).move_to(ORIGIN)\n        planet = Sphere(radius=0.2, color=BLUE).move_to(RIGHT * 5)\n\n        # Define the orbit path\n        orbit = Circle(radius=5, color=WHITE).set_stroke(width=2)\n\n        # Set up the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.add(sun, planet, orbit)\n        self.play(Rotate(planet, about_point=ORIGIN, angle=2*PI, run_time=10, rate_func=linear))\n        self.begin_ambient_camera_rotation(rate=0.1)\n        self.wait(10)"}]}
{"messages":[{"role":"system","content":"show an animation of the complex function f(z) = z^2 applied to the complex plane?"},{"role":"model","content":"from manim import *\n\nclass ComplexFunctionVisual(ThreeDScene):\n    def construct(self):\n        # Define the complex function: f(z) = z^2\n        def func(z):\n            return z**2\n\n        # Create a complex plane\n        plane = ComplexPlane().add_coordinates()\n        \n        # Map the complex function onto the plane\n        mapped_plane = plane.copy().apply_complex_function(func)\n\n        # Set up the scene\n        self.add(plane)\n        self.play(Transform(plane, mapped_plane))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of constructing a hexagon within a circle?"},{"role":"model","content":"from manim import *\n\nclass HexagonConstruction(Scene):\n    def construct(self):\n        # Center point\n        center = Dot()\n        # Initial circle\n        circle = Circle(radius=2)\n        circle.move_to(center)\n\n        # Points for hexagon\n        points = [circle.point_at_angle(i * PI / 3) for i in range(6)]\n        hexagon = Polygon(*points, color=BLUE)\n\n        # Construction animation\n        self.play(Create(center))\n        self.play(Create(circle))\n        self.play(Create(hexagon))\n        self.wait(1)\n\n        # Label vertices\n        labels = VGroup(*[Text(f\"P{i+1}\").next_to(points[i], DOWN, buff=0.1) for i in range(6)])\n        self.play(*[Write(label) for label in labels])\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a complex number and its conjugate on the Argand plane?"},{"role":"model","content":"from manim import *\n\nclass ComplexNumberVisual(Scene):\n    def construct(self):\n        # Create the Argand plane\n        plane = ComplexPlane(\n            axis_config={\"stroke_color\": WHITE}\n        ).add_coordinates()\n\n        # Define a complex number\n        z = complex(2, 1)\n        dot = Dot(plane.n2p(z), color=YELLOW)\n        label = MathTex(\"2+1i\").next_to(dot, UP)\n\n        # Visualize the complex number\n        self.play(Create(plane), run_time=1)\n        self.play(FadeIn(dot, scale=0.5), Write(label))\n        self.wait(1)\n\n        # Show its conjugate\n        z_conj = complex(2, -1)\n        dot_conj = Dot(plane.n2p(z_conj), color=RED)\n        label_conj = MathTex(\"2-1i\").next_to(dot_conj, DOWN)\n\n        self.play(FadeIn(dot_conj, scale=0.5), Write(label_conj))\n        self.wait(1)\n\n        # Connect with a line to show symmetry\n        line = Line(dot.get_center(), dot_conj.get_center(), color=BLUE)\n        self.play(Create(line))\n        self.wait(1)"}]}
{"messages":[{"role":"system","content":"show an animation of a point plotted in polar coordinates and its Cartesian conversion?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass PolarCoordinates(Scene):\n    def construct(self):\n        # Create both Cartesian and polar planes\n        plane = PolarPlane(\n            azimuth_units=\"degrees\", \n            radius_max=3\n        ).add_coordinates()\n        \n        # Define a point in polar coordinates (r, theta)\n        r, theta = 2, 45  # 45 degrees and radius 2\n        point_polar = plane.polar_to_point(r, theta * DEGREES)\n\n        # Plot the point\n        dot_polar = Dot(point_polar, color=GREEN)\n        label_polar = MathTex(r\"2\\text{ at } 45^\\circ\").next_to(dot_polar, RIGHT)\n\n        # Conversion to Cartesian coordinates\n        x, y = r * np.cos(theta * DEGREES), r * np.sin(theta * DEGREES)\n        label_cartesian = MathTex(f\"({x:.2f}, {y:.2f})\").next_to(dot_polar, DOWN)\n\n        # Visualize the point and its coordinates\n        self.play(Create(plane), run_time=1)\n        self.play(FadeIn(dot_polar, scale=0.5), Write(label_polar))\n        self.wait(1)\n        self.play(Write(label_cartesian))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of the volume of revolution for the function \\sqrt{x} + 1?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass VolumeOfRevolution(ThreeDScene):\n    def construct(self):\n        # Define axes\n        axes = ThreeDAxes(\n            x_range=[0, 3, 1],\n            y_range=[0, 3, 1],\n            z_range=[0, 3, 1],\n            x_length=5,\n            y_length=5,\n            z_length=5\n        )\n\n        # Define a function\n        func = lambda x: np.sqrt(x) + 1\n        curve = ParametricFunction(\n            lambda t: axes.c2p(t, func(t), 0),\n            t_range=[0, 3],\n            color=BLUE\n        )\n\n        # Create a revolved surface\n        surface = Surface(\n            lambda u, v: axes.c2p(u, func(u) * np.cos(v), func(u) * np.sin(v)),\n            u_range=[0, 3],\n            v_range=[0, TAU],\n            checkerboard_colors=[BLUE_D, BLUE_E]\n        )\n\n        # Set up the scene\n        self.set_camera_orientation(phi=75 * DEGREES, theta=-45 * DEGREES)\n        self.add(axes, curve)\n        self.play(Create(surface))\n        self.begin_ambient_camera_rotation(rate=0.2)\n        self.wait(5)"}]}
{"messages":[{"role":"system","content":"show an animation of the improper integral \\int_1^\\infty \\frac{1}{x+1} \\, dx?"},{"role":"model","content":"from manim import *\n\nclass ImproperIntegral(Scene):\n    def construct(self):\n        # Define axes\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[0, 1.5, 0.5],\n            axis_config={\"include_tip\": True, \"include_numbers\": True}\n        )\n\n        # Define a function that approaches 0 as x approaches infinity\n        func = axes.plot(lambda x: 1 / (x + 1), color=BLUE, x_range=[0.01, 9])\n\n        # Highlight the area under the curve to infinity (simulated to a large number)\n        area = axes.get_area(func, x_range=[1, 9], color=BLUE, opacity=0.3)\n\n        # Labels and annotations\n        func_label = MathTex(r\"y = \\frac{1}{x+1}\").next_to(func, RIGHT)\n        integral_label = MathTex(r\"\\int_1^\\infty \\frac{1}{x+1} \\, dx\").to_edge(UP)\n\n        # Show the elements\n        self.play(Create(axes), Create(func))\n        self.play(Write(func_label))\n        self.play(FadeIn(area, scale=0.5))\n        self.play(Write(integral_label))\n        self.wait(2)\n\n        # Extend the area animation towards infinity (simulation)\n        self.play(area.animate.scale(1.5, about_point=axes.c2p(9, 0)))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of solving the differential equation \\frac{dy}{dx} = y with the initial condition y(0) = 1?"},{"role":"model","content":"from manim import *\nimport numpy as np\nfrom scipy.integrate import odeint\n\nclass SimpleDE(Scene):\n    def construct(self):\n        # Define axes\n        axes = Axes(\n            x_range=[0, 5],\n            y_range=[0, 10],\n            axis_config={\"include_tip\": True}\n        )\n\n        # Define the differential equation dy/dx = y\n        def diff_eq(y, x):\n            return y\n\n        # Initial condition\n        y0 = 1\n\n        # Range for x values\n        x = np.linspace(0, 5, 400)\n\n        # Solve the differential equation\n        y = odeint(diff_eq, y0, x)\n        y = np.array(y).flatten()  # Flatten the solution array\n\n        # Create the graph of the solution\n        solution = axes.plot_line_graph(x, y, add_vertex_dots=False, line_color=BLUE)\n\n        # Add labels\n        solution_label = MathTex(r\"\\frac{dy}{dx} = y\", r\"\\quad y(0) = 1\").to_edge(UP)\n\n        # Show everything\n        self.play(Create(axes))\n        self.play(Create(solution), Write(solution_label))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of solving the second-order differential equation \\frac{d^2y}{dx^2} + y = 0 with initial conditions y(0) = 0 and y'(0) = 1?"},{"role":"model","content":"from manim import *\nimport numpy as np\nfrom scipy.integrate import odeint\n\nclass SecondOrderDE(Scene):\n    def construct(self):\n        # Define axes\n        axes = Axes(\n            x_range=[0, 10],\n            y_range=[-2, 2],\n            axis_config={\"include_tip\": True}\n        )\n\n        # Define the second-order differential equation as a system of first-order equations\n        # For the equation d^2y/dx^2 + y = 0, let u = y and v = dy/dx\n        # Then, du/dx = v and dv/dx = -u\n        def system(state, t):\n            u, v = state\n            return [v, -u]\n\n        # Initial conditions: u(0) = 0 (position), v(0) = 1 (velocity)\n        initial_conditions = [0, 1]\n\n        # Range for t values\n        t = np.linspace(0, 10, 400)\n\n        # Solve the system of differential equations\n        sol = odeint(system, initial_conditions, t)\n\n        # Extract solutions\n        u, v = sol.T  # u is position, v is velocity\n\n        # Create the graph of the position\n        solution = axes.plot_line_graph(t, u, add_vertex_dots=False, line_color=GREEN)\n\n        # Add labels\n        solution_label = MathTex(r\"\\frac{d^2y}{dx^2} + y = 0\", r\"\\quad y(0) = 0, y'(0) = 1\").to_edge(UP)\n\n        # Show everything\n        self.play(Create(axes))\n        self.play(Create(solution), Write(solution_label))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of the permutations of the letters ABC?"},{"role":"model","content":"from manim import *\n\nclass PermutationsScene(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Permutations of ABC\").scale(0.9)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n\n        # Permutations of ABC\n        items = Text(\"ABC\").scale(1.2)\n        self.play(Write(items))\n        self.wait(1)\n\n        # Show permutations\n        permutations = [\n            \"ABC\", \"ACB\", \"BAC\", \"BCA\", \"CAB\", \"CBA\"\n        ]\n        perm_texts = VGroup(*[Text(perm).scale(0.8) for perm in permutations])\n        perm_texts.arrange_in_grid(rows=2, cols=3, buff=1)\n        self.play(Transform(items, perm_texts))\n        self.wait(2)\n\n        # Count permutations\n        count_text = Text(f\"Total permutations = {len(permutations)}\").scale(0.8).to_edge(DOWN)\n        self.play(Write(count_text))\n        self.wait(2)\n\n        # Explanation\n        explanation_text = MathTex(r\"P(n) = n! = 3! = 6\").to_edge(DOWN)\n        self.play(ReplacementTransform(count_text, explanation_text))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of the combinations of the letters ABC taken 2 at a time?"},{"role":"model","content":"from manim import *\n\nclass CombinationsScene(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Combinations of ABC taken 2 at a time\").scale(0.8)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n\n        # All possible combinations\n        combinations = [\n            \"AB\", \"AC\", \"BC\"\n        ]\n        combo_texts = VGroup(*[Text(combo).scale(0.9) for combo in combinations])\n        combo_texts.arrange_in_grid(rows=1, cols=3, buff=1)\n        self.play(Write(combo_texts))\n        self.wait(2)\n\n        # Count combinations\n        count_text = Text(f\"Total combinations = {len(combinations)}\").scale(0.8).to_edge(DOWN)\n        self.play(Write(count_text))\n        self.wait(2)\n\n        # Explanation\n        explanation_text = MathTex(r\"C(n, k) = \\binom{n}{k} = \\binom{3}{2} = 3\").to_edge(DOWN)\n        self.play(ReplacementTransform(count_text, explanation_text))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of the Binomial Theorem for (a + b)^2 and its connection to Pascal's Triangle?"},{"role":"model","content":"from manim import *\n\nclass BinomialTheoremScene(Scene):\n    def construct(self):\n        # Title and introduction\n        title = Text(\"Binomial Theorem: (a + b)^2\").scale(0.9)\n        self.play(Write(title))\n        self.wait(1)\n        self.play(title.animate.to_edge(UP))\n\n        # Binomial expansion\n        expansion_formula = MathTex(\"(a + b)^2 = a^2 + 2ab + b^2\")\n        self.play(Write(expansion_formula))\n        self.wait(1)\n\n        # Show Pascal's Triangle related to the binomial coefficients\n        # Each row in Pascal's Triangle is broken into separate MathTex objects for individual manipulation\n        pascals_triangle = VGroup(\n            MathTex(r\"1\"),\n            MathTex(r\"1\\quad 1\"),\n            MathTex(r\"1\\quad 2\\quad 1\"),\n            MathTex(r\"1\\quad 3\\quad 3\\quad 1\")\n        ).arrange(DOWN, aligned_edge=LEFT, buff=0.5)\n        pascals_triangle.next_to(expansion_formula, DOWN, buff=0.5)\n\n        # Adjust the last row if necessary\n        pascals_triangle[-1].shift(UP * 0.2)  # Shift the last row slightly upward\n\n        self.play(Write(pascals_triangle))\n        self.wait(1)\n\n        # Highlight the third row (0-indexed, so row 2)\n        highlight = SurroundingRectangle(pascals_triangle[2], color=YELLOW)\n        self.play(Create(highlight))\n        self.wait(2)\n\n        # Explanation of coefficients\n        explanation_text = Text(\"Coefficients come from Pascal's Triangle\", font_size=24)\n        explanation_text.next_to(pascals_triangle, DOWN)\n        self.play(Write(explanation_text))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of decomposing a square wave using its Fourier series?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass FourierSeriesDecomposition(Scene):\n    def construct(self):\n        # Define axes\n        axes = Axes(\n            x_range=[0, 10, 1],\n            y_range=[-2, 2, 1],\n            x_length=10,\n            y_length=3,\n            axis_config={\"color\": BLUE}\n        )\n        \n        # Define the square wave using Fourier series approximation\n        def fourier_series(x, n_terms=5):\n            s = 0\n            for n in range(1, n_terms + 1):\n                s += (np.sin((2 * n - 1) * x)) / (2 * n - 1)\n            return 4 / np.pi * s\n\n        # Plot the square wave\n        square_wave = axes.plot(lambda x: fourier_series(x * PI), color=RED, x_range=[0, 10])\n        square_wave_label = MathTex(\"f(x) = \\\\sum_{n=1}^{\\\\infty} \\\\frac{4}{\\\\pi} \\\\frac{\\\\sin((2n-1)x)}{2n-1}\").next_to(axes, UP)\n\n        # Initialize group for components and their labels\n        components = VGroup()\n        label_group = VGroup()\n\n        # Create and plot individual Fourier series terms and their labels\n        for n in range(1, 6):  # First 5 terms of the Fourier series\n            component = axes.plot(lambda x: 4 / np.pi * np.sin((2 * n - 1) * x * PI) / (2 * n - 1),\n                                  color=random_bright_color(), x_range=[0, 10])\n            label = MathTex(f\"4/\\\\pi \\\\cdot \\\\sin({2*n-1}x)/{2*n-1}\").scale(0.7)\n            components.add(component)\n            label_group.add(label)\n\n        # Arrange labels below the axes\n        label_group.arrange(DOWN, aligned_edge=LEFT, buff=0.1)\n        label_group.next_to(axes, DOWN, buff=0.1)\n\n        # Show the axes and the square wave\n        self.play(Create(axes))\n        self.play(Create(square_wave), Write(square_wave_label))\n        self.wait(2)\n\n        # Show components one by one with labels\n        for component, label in zip(components, label_group):\n            self.play(Create(component))\n            self.play(Write(label))\n            self.wait(0.5)\n\n        # Explain addition of components\n        addition_label = MathTex(r\"\\\\text{Sum of first 5 components approximates } f(x)\").to_edge(UP)\n        self.play(Transform(square_wave_label, addition_label))\n        self.wait(2)\n\n        # Sum the components to show how they approximate the square wave\n        self.play(FadeOut(components), FadeOut(label_group), FadeIn(square_wave), ReplacementTransform(addition_label, square_wave_label))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of a neural network's forward pass?"},{"role":"model","content":"from manim import *\nimport numpy as np\n\nclass NeuralNetworkForwardPass(Scene):\n    def construct(self):\n        # Scene Heading\n        title = Text(\"Neural Network Forward Pass Visualization\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Define the layout of the network\n        layer_sizes = [3, 5, 4, 2]  # Example sizes (input, hidden layers, output)\n        layers = VGroup(*[self.create_layer(size) for size in layer_sizes])\n\n        # Position layers\n        layers.arrange(RIGHT, buff=1.5)\n        self.play(*[Create(layer) for layer in layers])\n\n        # Connect neurons with edges\n        for i in range(len(layers) - 1):\n            self.play(*[Create(line) for line in self.connect_layers(layers[i], layers[i + 1])])\n\n        # Label layers\n        layer_labels = [\"Input Layer\", \"Hidden Layer 1\", \"Hidden Layer 2\", \"Output Layer\"]\n        labels = VGroup(*[\n            Text(f\"{layer_labels[i]}\", font_size=20).next_to(layer, UP)\n            for i, layer in enumerate(layers)\n        ])\n        self.play(*[Write(label) for label in labels])\n\n        # Animate data flow\n        input_data = [1, 0.5, -1]  # Example input\n        activations = self.forward_pass(layers, input_data)\n        self.wait(1)\n    def create_layer(self, size):\n        return VGroup(*[\n            Circle(radius=0.2, fill_color=BLUE, fill_opacity=0.5, stroke_color=WHITE, stroke_width=2)\n            for _ in range(size)\n        ]).arrange(DOWN, buff=0.5)\n    def connect_layers(self, layer1, layer2):\n        return [\n            Line(start.get_center(), end.get_center(), buff=0.1, stroke_width=2)\n            for start in layer1 for end in layer2\n        ]\n    def forward_pass(self, layers, input_data):\n        activations = input_data\n        for i, layer in enumerate(layers):\n            new_activations = []\n            for j, neuron in enumerate(layer):\n                neuron_activation = activations[j] if j < len(activations) else 0\n                if neuron_activation > 0:\n                    neuron.set_fill(RED, opacity=neuron_activation)\n                elif neuron_activation < 0:\n                    neuron.set_fill(BLUE, opacity=-neuron_activation)\n                else:\n                    neuron.set_fill(WHITE, opacity=0)\n                new_activations.append(np.tanh(neuron_activation))\n            activations = new_activations\n            self.wait(0.5)\n        return activations"}]}
{"messages":[{"role":"system","content":"show an animation of an ecosystem food web?"},{"role":"model","content":"from manim import *\n\n# Define BROWN color\nBROWN = \"#8B4513\"\n\nclass EcosystemFoodWeb(Scene):\n    def construct(self):\n        # Scene title\n        title = Text(\"Ecosystem Food Web Complexity\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n        self.wait(1)\n\n        # Create food web components\n        plants = Circle(color=GREEN, fill_opacity=1).shift(DOWN * 2)\n        plants_label = Text(\"Plants\", color=WHITE, font_size=18).move_to(plants.get_center())\n\n        herbivores = Circle(color=BLUE, fill_opacity=1).shift(LEFT * 2)\n        herbivores_label = Text(\"Herbivores\", color=WHITE, font_size=18).move_to(herbivores.get_center())\n\n        carnivores = Circle(color=RED, fill_opacity=1).shift(RIGHT * 2)\n        carnivores_label = Text(\"Carnivores\", color=WHITE, font_size=18).move_to(carnivores.get_center())\n\n        decomposers = Circle(color=BROWN, fill_opacity=1).shift(UP * 2)\n        decomposers_label = Text(\"Decomposers\", color=WHITE, font_size=18).move_to(decomposers.get_center())\n\n        # Show ecosystem components\n        self.play(Create(plants), Write(plants_label))\n        self.play(Create(herbivores), Write(herbivores_label))\n        self.play(Create(carnivores), Write(carnivores_label))\n        self.play(Create(decomposers), Write(decomposers_label))\n        self.wait(2)\n\n        # Draw connections between components\n        self.play(\n            *[Create(Arrow(start.get_center(), end.get_center(), buff=0.1, stroke_width=2))\n              for start, end in [\n                  (plants, herbivores),\n                  (herbivores, carnivores),\n                  (carnivores, decomposers),\n                  (decomposers, plants)\n              ]]\n        )\n\n        # Explain specific interactions\n        interaction_texts = VGroup(\n            Text(\"Energy Flow\").scale(0.7).next_to(plants, RIGHT),\n            Text(\"Predation\").scale(0.7).next_to(herbivores, UP),\n            Text(\"Decomposition\").scale(0.7).next_to(decomposers, LEFT)\n        )\n        self.play(*[Write(text) for text in interaction_texts])\n        self.wait(2)\n\n        # Conclusion\n        conclusion_text = Text(\"Understanding Food Webs\", font_size=20).next_to(title, DOWN)\n        self.play(Write(conclusion_text))\n        self.wait(2)"}]}
{"messages":[{"role":"system","content":"show an animation of molecular orbital formation in H2?"},{"role":"model","content":"from manim import *\n\nclass MolecularOrbitalVisualization(Scene):\n    def construct(self):\n        # Title of the scene\n        title = Text(\"Molecular Orbital Formation in H2\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n\n        # Create atomic orbitals\n        left_orbital = Circle(color=RED, fill_opacity=0.5).shift(LEFT * 2)\n        right_orbital = Circle(color=BLUE, fill_opacity=0.5).shift(RIGHT * 2)\n        orbitals_label = Text(\"Atomic Orbitals (1s)\", color=WHITE, font_size=17).next_to(left_orbital, UP, buff=0.5)\n        \n        self.play(Create(left_orbital), Create(right_orbital), Write(orbitals_label))\n        self.wait(1)\n\n        # Demonstrate overlapping to form molecular orbitals\n        bonding_orbital = left_orbital.copy().set_color(GREEN).move_to(ORIGIN).scale(1.2)\n        antibonding_orbital = right_orbital.copy().set_color(RED).move_to(ORIGIN).scale(1.2)\n\n        bonding_label = Text(\"Bonding Orbital ()\", font_size=14).next_to(bonding_orbital, UP)\n        antibonding_label = Text(\"Antibonding Orbital (*)\", font_size=15).next_to(antibonding_orbital, DOWN)\n\n        self.play(Transform(left_orbital, bonding_orbital), Transform(right_orbital, antibonding_orbital))\n        self.play(Write(bonding_label), Write(antibonding_label))\n        self.wait(2)\n\n      # Explanation text\n        explanation_text = Text(\n            \"Bonding orbitals result from constructive interference,\\n\"\n            \"and antibonding orbitals from destructive interference.\",\n            font_size=20\n        ).to_edge(DOWN)\n        self.play(Write(explanation_text))\n        self.wait(3)"}]}
{"messages":[{"role":"system","content":"show an animation of the derivative using the function y = x^2?"},{"role":"model","content":"from manim import *\n\nclass DerivativeVisualization(Scene):\n    def construct(self):\n        # Create title and display it\n        title = Text(\"Visualization of the Derivative\", font_size=24).to_edge(UP)\n        self.play(Write(title))\n\n        # Define axes\n        axes = Axes(\n            x_range=[-3, 3, 1],\n            y_range=[-5, 5, 1],\n            axis_config={\"include_numbers\": True},\n            tips=True\n        )\n        \n        # Define and plot the function graph y = x^2\n        graph = axes.plot(lambda x: x**2, color=BLUE, x_range=[-2, 2])\n        graph_label = axes.get_graph_label(graph, label='y = x^2').next_to(graph, UR, buff=0.5)\n\n        # Display axes and graph\n        self.play(Create(axes), Create(graph), Write(graph_label))\n        self.wait(1)\n\n        # Point of interest for the derivative at x = 1\n        x_value = 1\n        point_of_interest = axes.input_to_graph_point(x_value, graph)\n        dot = Dot(point=point_of_interest, color=RED)\n        dot_label = MathTex(f\"x={x_value}\", color=RED).next_to(dot, UP+RIGHT)\n\n        # Create and display tangent line at x = 1\n        tangent_line = always_redraw(lambda: self.get_tangent_line(axes, x_value, graph, dx=0.01, color=ORANGE))\n        \n        self.play(FadeIn(dot), Write(dot_label))\n        self.play(Create(tangent_line))\n        self.wait(2)\n\n        # Display slope calculation at x = 1\n        slope = 2 * x_value  # Derivative of x^2 at x is 2x\n        slope_text = MathTex(\"Slope =\", f\"{slope}\", color=ORANGE).to_corner(DL)  # Position at bottom left\n\n        self.play(Write(slope_text))\n        self.wait(2)\n\n        # Move point to show different tangents and slopes at new x values\n        for new_x in [-1.5, 0, 1.5]:\n            new_point = axes.input_to_graph_point(new_x, graph)\n            new_slope = 2 * new_x\n            new_slope_text = MathTex(\"Slope =\", f\"{new_slope:.2f}\", color=ORANGE)\n\n            self.play(\n                dot.animate.move_to(new_point),\n                Transform(dot_label, MathTex(f\"x={new_x:.1f}\", color=RED).next_to(dot, UP+RIGHT)),\n                Transform(slope_text, new_slope_text)\n            )\n            self.wait(1)\n        \n        # Conclusion about the concept of derivatives\n        conclusion_text = Text(\"The slope of the tangent line represents the derivative at that point.\",\n                               font_size=20, color=BLUE).to_edge(DOWN)\n        self.play(Write(conclusion_text))\n        self.wait(3)\n\n    def get_tangent_line(self, axes, x, graph, dx=0.01, color=ORANGE):\n        \"\"\" Calculate the tangent line using the derivative definition \"\"\"\n        p1 = axes.input_to_graph_point(x - dx, graph)\n        p2 = axes.input_to_graph_point(x + dx, graph)\n        line = Line(p1, p2, color=color)\n        line.scale(2)  # Extend the line length for better visibility\n        return line"}]}